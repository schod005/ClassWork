/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "DHTNode_NodeInterface_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kFlagsValues[] = {
  Flags::LOG
};
const char* _kFlagsNames[] = {
  "LOG"
};
const std::map<int, const char*> _Flags_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFlagsValues, _kFlagsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


UpdateDHTInfo::~UpdateDHTInfo() throw() {
}


void UpdateDHTInfo::__set_ID(const int64_t val) {
  this->ID = val;
}

void UpdateDHTInfo::__set_port(const int16_t val) {
  this->port = val;
}

void UpdateDHTInfo::__set_ipAddress(const std::string& val) {
  this->ipAddress = val;
}

uint32_t UpdateDHTInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ID);
          this->__isset.ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ipAddress);
          this->__isset.ipAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateDHTInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateDHTInfo");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ipAddress", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ipAddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateDHTInfo &a, UpdateDHTInfo &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.port, b.port);
  swap(a.ipAddress, b.ipAddress);
  swap(a.__isset, b.__isset);
}

UpdateDHTInfo::UpdateDHTInfo(const UpdateDHTInfo& other0) {
  ID = other0.ID;
  port = other0.port;
  ipAddress = other0.ipAddress;
  __isset = other0.__isset;
}
UpdateDHTInfo& UpdateDHTInfo::operator=(const UpdateDHTInfo& other1) {
  ID = other1.ID;
  port = other1.port;
  ipAddress = other1.ipAddress;
  __isset = other1.__isset;
  return *this;
}
void UpdateDHTInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateDHTInfo(";
  out << "ID=" << to_string(ID);
  out << ", " << "port=" << to_string(port);
  out << ", " << "ipAddress=" << to_string(ipAddress);
  out << ")";
}


LogInfo::~LogInfo() throw() {
}


void LogInfo::__set_nodesVisited(const std::vector<int64_t> & val) {
  this->nodesVisited = val;
}

void LogInfo::__set_fileLocation(const int64_t val) {
  this->fileLocation = val;
}

uint32_t LogInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodesVisited.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->nodesVisited.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readI64(this->nodesVisited[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodesVisited = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fileLocation);
          this->__isset.fileLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LogInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LogInfo");

  xfer += oprot->writeFieldBegin("nodesVisited", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nodesVisited.size()));
    std::vector<int64_t> ::const_iterator _iter7;
    for (_iter7 = this->nodesVisited.begin(); _iter7 != this->nodesVisited.end(); ++_iter7)
    {
      xfer += oprot->writeI64((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileLocation", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fileLocation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LogInfo &a, LogInfo &b) {
  using ::std::swap;
  swap(a.nodesVisited, b.nodesVisited);
  swap(a.fileLocation, b.fileLocation);
  swap(a.__isset, b.__isset);
}

LogInfo::LogInfo(const LogInfo& other8) {
  nodesVisited = other8.nodesVisited;
  fileLocation = other8.fileLocation;
  __isset = other8.__isset;
}
LogInfo& LogInfo::operator=(const LogInfo& other9) {
  nodesVisited = other9.nodesVisited;
  fileLocation = other9.fileLocation;
  __isset = other9.__isset;
  return *this;
}
void LogInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LogInfo(";
  out << "nodesVisited=" << to_string(nodesVisited);
  out << ", " << "fileLocation=" << to_string(fileLocation);
  out << ")";
}


WriteFile::~WriteFile() throw() {
}


void WriteFile::__set_file(const std::string& val) {
  this->file = val;
}

void WriteFile::__set_filesize(const int64_t val) {
  this->filesize = val;
}

void WriteFile::__set_filename(const std::string& val) {
  this->filename = val;
}

uint32_t WriteFile::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->file);
          this->__isset.file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filesize);
          this->__isset.filesize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          this->__isset.filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriteFile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteFile");

  xfer += oprot->writeFieldBegin("file", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->file);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filesize", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->filesize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteFile &a, WriteFile &b) {
  using ::std::swap;
  swap(a.file, b.file);
  swap(a.filesize, b.filesize);
  swap(a.filename, b.filename);
  swap(a.__isset, b.__isset);
}

WriteFile::WriteFile(const WriteFile& other10) {
  file = other10.file;
  filesize = other10.filesize;
  filename = other10.filename;
  __isset = other10.__isset;
}
WriteFile& WriteFile::operator=(const WriteFile& other11) {
  file = other11.file;
  filesize = other11.filesize;
  filename = other11.filename;
  __isset = other11.__isset;
  return *this;
}
void WriteFile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteFile(";
  out << "file=" << to_string(file);
  out << ", " << "filesize=" << to_string(filesize);
  out << ", " << "filename=" << to_string(filename);
  out << ")";
}


ReadFile::~ReadFile() throw() {
}


void ReadFile::__set_error(const bool val) {
  this->error = val;
}

void ReadFile::__set_errorMessage(const std::string& val) {
  this->errorMessage = val;
}

void ReadFile::__set_file(const std::string& val) {
  this->file = val;
}

void ReadFile::__set_filesize(const int64_t val) {
  this->filesize = val;
}

void ReadFile::__set_filename(const std::string& val) {
  this->filename = val;
}

void ReadFile::__set_log(const LogInfo& val) {
  this->log = val;
}

uint32_t ReadFile::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorMessage);
          this->__isset.errorMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->file);
          this->__isset.file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filesize);
          this->__isset.filesize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          this->__isset.filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->log.read(iprot);
          this->__isset.log = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReadFile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReadFile");

  xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorMessage", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->errorMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->file);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filesize", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->filesize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("log", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->log.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadFile &a, ReadFile &b) {
  using ::std::swap;
  swap(a.error, b.error);
  swap(a.errorMessage, b.errorMessage);
  swap(a.file, b.file);
  swap(a.filesize, b.filesize);
  swap(a.filename, b.filename);
  swap(a.log, b.log);
  swap(a.__isset, b.__isset);
}

ReadFile::ReadFile(const ReadFile& other12) {
  error = other12.error;
  errorMessage = other12.errorMessage;
  file = other12.file;
  filesize = other12.filesize;
  filename = other12.filename;
  log = other12.log;
  __isset = other12.__isset;
}
ReadFile& ReadFile::operator=(const ReadFile& other13) {
  error = other13.error;
  errorMessage = other13.errorMessage;
  file = other13.file;
  filesize = other13.filesize;
  filename = other13.filename;
  log = other13.log;
  __isset = other13.__isset;
  return *this;
}
void ReadFile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReadFile(";
  out << "error=" << to_string(error);
  out << ", " << "errorMessage=" << to_string(errorMessage);
  out << ", " << "file=" << to_string(file);
  out << ", " << "filesize=" << to_string(filesize);
  out << ", " << "filename=" << to_string(filename);
  out << ", " << "log=" << to_string(log);
  out << ")";
}


myInfo::~myInfo() throw() {
}


void myInfo::__set_ID(const int64_t val) {
  this->ID = val;
}

void myInfo::__set_minKey(const int64_t val) {
  this->minKey = val;
}

void myInfo::__set_maxKey(const int64_t val) {
  this->maxKey = val;
}

void myInfo::__set_predecessor(const int64_t val) {
  this->predecessor = val;
}

void myInfo::__set_successor(const int64_t val) {
  this->successor = val;
}

void myInfo::__set_numFiles(const int64_t val) {
  this->numFiles = val;
}

void myInfo::__set_files(const std::vector<std::string> & val) {
  this->files = val;
}

void myInfo::__set_fingerTable(const std::map<int64_t, UpdateDHTInfo> & val) {
  this->fingerTable = val;
}

uint32_t myInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ID);
          this->__isset.ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minKey);
          this->__isset.minKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxKey);
          this->__isset.maxKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->predecessor);
          this->__isset.predecessor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->successor);
          this->__isset.successor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numFiles);
          this->__isset.numFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->files.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readString(this->files[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fingerTable.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            xfer += iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              int64_t _key24;
              xfer += iprot->readI64(_key24);
              UpdateDHTInfo& _val25 = this->fingerTable[_key24];
              xfer += _val25.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fingerTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t myInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("myInfo");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minKey", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->minKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxKey", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->maxKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("predecessor", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->predecessor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("successor", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->successor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numFiles", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->numFiles);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
    std::vector<std::string> ::const_iterator _iter26;
    for (_iter26 = this->files.begin(); _iter26 != this->files.end(); ++_iter26)
    {
      xfer += oprot->writeString((*_iter26));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fingerTable", ::apache::thrift::protocol::T_MAP, 8);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fingerTable.size()));
    std::map<int64_t, UpdateDHTInfo> ::const_iterator _iter27;
    for (_iter27 = this->fingerTable.begin(); _iter27 != this->fingerTable.end(); ++_iter27)
    {
      xfer += oprot->writeI64(_iter27->first);
      xfer += _iter27->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(myInfo &a, myInfo &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.minKey, b.minKey);
  swap(a.maxKey, b.maxKey);
  swap(a.predecessor, b.predecessor);
  swap(a.successor, b.successor);
  swap(a.numFiles, b.numFiles);
  swap(a.files, b.files);
  swap(a.fingerTable, b.fingerTable);
  swap(a.__isset, b.__isset);
}

myInfo::myInfo(const myInfo& other28) {
  ID = other28.ID;
  minKey = other28.minKey;
  maxKey = other28.maxKey;
  predecessor = other28.predecessor;
  successor = other28.successor;
  numFiles = other28.numFiles;
  files = other28.files;
  fingerTable = other28.fingerTable;
  __isset = other28.__isset;
}
myInfo& myInfo::operator=(const myInfo& other29) {
  ID = other29.ID;
  minKey = other29.minKey;
  maxKey = other29.maxKey;
  predecessor = other29.predecessor;
  successor = other29.successor;
  numFiles = other29.numFiles;
  files = other29.files;
  fingerTable = other29.fingerTable;
  __isset = other29.__isset;
  return *this;
}
void myInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "myInfo(";
  out << "ID=" << to_string(ID);
  out << ", " << "minKey=" << to_string(minKey);
  out << ", " << "maxKey=" << to_string(maxKey);
  out << ", " << "predecessor=" << to_string(predecessor);
  out << ", " << "successor=" << to_string(successor);
  out << ", " << "numFiles=" << to_string(numFiles);
  out << ", " << "files=" << to_string(files);
  out << ", " << "fingerTable=" << to_string(fingerTable);
  out << ")";
}


