// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DHTNode_NodeInterface.h"
#include "../gen-cpp-super/DHTNode_SupernodeInterface.h"
#include <thrift/transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <boost/functional/hash.hpp>
#include <pthread.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <netinet/in.h>
#include <string.h>
#include <arpa/inet.h>
#include <iostream>
#include <cmath>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

#define DHT_SIZE 32
//define DEBUG to enable output
#define DEBUG

UpdateDHTInfo successor(const std::vector<UpdateDHTInfo> & NodesList, int id);
int predecessor(const std::vector<UpdateDHTInfo> & NodesList, int id);

class DHTNode_NodeInterfaceHandler : virtual public DHTNode_NodeInterfaceIf {
  private:
    std::map<long int, UpdateDHTInfo> m_fingertable;
    std::map<std::string, std::string> m_files;
    std::pair<unsigned int, unsigned int> m_range;
    int m_predecessor;
    int m_successor;
    int m_ID;

    int fingertable_closest_preceding(int ID);

  public:
    DHTNode_NodeInterfaceHandler() {
      // Your initialization goes here
    }

    void Write(LogInfo& _return, const WriteFile& fileInfo, const int64_t flags) {
      //hash the filename
      boost::hash<std::string> hash_fn;
      unsigned int hash = hash_fn(fileInfo.filename);
      hash %= DHT_SIZE;
      #ifdef DEBUG
      std::cout << "Hash = " << hash << " ";
      #endif
      //I am responsible for this hash
      if((m_range.first < m_range.second && m_range.first <= hash && hash <= m_range.second) ||
          (m_range.first > m_range.second && (m_range.first <= hash || hash <= m_range.second)) ||
          (m_range.first == m_range.second && m_range.second == hash))
      {
        #ifdef DEBUG
        std::cout << "Writing " << fileInfo.filename << " to storage" << std::endl;
        #endif
        m_files[fileInfo.filename] = fileInfo.file;
      }
      else //I am not responsible for this hash
      {
        int ftable_index = fingertable_closest_preceding(hash); // find node to forward to
        int ID = m_fingertable[ftable_index].ID;
        int port = m_fingertable[ftable_index].port;
        std::string ip_Address = m_fingertable[ftable_index].ipAddress;
        #ifdef DEBUG
        std::cout << "Forwarding to " << ID << " " << ip_Address
          << ":" << port << std::endl;
        #endif
        boost::shared_ptr<TSocket> DHTsocket(new TSocket(ip_Address, port));
        boost::shared_ptr<TTransport> DHTtransport(new TBufferedTransport(DHTsocket));
        boost::shared_ptr<TProtocol> DHTprotocol(new TBinaryProtocol(DHTtransport));
        DHTNode_NodeInterfaceClient DHTNode(DHTprotocol);

        //connect to node and call write
        DHTtransport->open();
        DHTNode.Write(_return, fileInfo, flags);
        DHTtransport->close();
      }
      _return.nodesVisited.push_back(m_ID);

      printf("Write\n");
    }

    void Read(ReadFile& _return, const std::string& filename, const int64_t flags) {
      //hash the filename
      boost::hash<std::string> hash_fn;
      unsigned int hash = hash_fn(filename);
      hash %= DHT_SIZE;
      #ifdef DEBUG
      std::cout << "Hash = " << hash << " ";
      #endif
      if((m_range.first < m_range.second && m_range.first <= hash && hash <= m_range.second) ||
          (m_range.first > m_range.second && (m_range.first <= hash || hash <= m_range.second)) ||
         (m_range.first == m_range.second && m_range.second == hash))
      {
        #ifdef DEBUG
        std::cout << "Reading " << filename << " from storage" << std::endl;
        #endif
        std::map<std::string, std::string>::iterator iter = m_files.find(filename);
        if(iter != m_files.end())
        {
          _return.filename = filename;
          _return.file = m_files[filename];
          _return.error = false;
        }
        else
        {
          _return.error = true;
          _return.errorMessage = "File does not exist";
        }
      }
      else
      {
        int ftable_index = fingertable_closest_preceding(hash); // find node to forward to
        int ID = m_fingertable[ftable_index].ID;
        int port = m_fingertable[ftable_index].port;
        std::string ip_Address = m_fingertable[ftable_index].ipAddress;
        #ifdef DEBUG
        std::cout << "Forwarding to " << ID << " " << ip_Address
          << ":" << port << std::endl;
        #endif
        boost::shared_ptr<TSocket> DHTsocket(new TSocket(ip_Address, port));
        boost::shared_ptr<TTransport> DHTtransport(new TBufferedTransport(DHTsocket));
        boost::shared_ptr<TProtocol> DHTprotocol(new TBinaryProtocol(DHTtransport));
        DHTNode_NodeInterfaceClient DHTNode(DHTprotocol);

        //connect to node and call write
        DHTtransport->open();
        DHTNode.Read(_return, filename, flags);
        DHTtransport->close();
      }

      _return.log.nodesVisited.push_back(m_ID);
      printf("Read\n");
    }

    void UpdateDHT(const std::vector<UpdateDHTInfo> & NodesList) {
      int table_size = log2(DHT_SIZE);
      for(int i = 1; i <= table_size; i++) //update fingertable
      {
        m_fingertable[i] = successor(NodesList, (m_ID + (int)pow(2, i - 2)) % DHT_SIZE);
      }
      m_range.second = m_ID;
      m_range.first = predecessor(NodesList, m_ID);

      m_successor = successor(NodesList, m_ID).ID;
      if(m_range.first == 0)
        m_predecessor = DHT_SIZE - 1;
      else
        m_predecessor = m_range.first - 1;


      #ifdef DEBUG
      std::cout << std::endl << "Fingertable:\n";
      for(std::map<long int, UpdateDHTInfo>::iterator i = m_fingertable.begin(); i != m_fingertable.end(); i++)
      {
        std::cout << i->first << ": " << i->second.ID << "\t"
          << i->second.ipAddress << ":"
          << i->second.port << "\n";
      }

      std::cout << std::endl << "I am responsible for hashes: " << m_range.first << "-"
        << m_range.second << std::endl;
      #endif
      printf("UpdateDHT\n");
    }

    void getInfo(myInfo& _return) {
      _return.ID = m_ID;
      _return.minKey = m_range.first;
      _return.maxKey = m_range.second;
      _return.predecessor = m_predecessor;
      _return.successor = m_successor;
      _return.numFiles = m_files.size();
      std::vector<std::string> fileList;
      for(std::map<std::string, std::string>::iterator file = m_files.begin(); file != m_files.end(); file++)
        fileList.push_back(file->first);
      _return.files = fileList;
      _return.fingerTable = m_fingertable;

      printf("getInfo\n");
    }

    void setID(int id){m_ID = id;}
};

int DHTNode_NodeInterfaceHandler::fingertable_closest_preceding(int id)
{
  if((m_ID <= id && m_fingertable[1].ID >= id) || ((m_ID > m_fingertable[1].ID) &&
        ((m_ID > id && m_fingertable[1].ID >= id) || (m_ID < id && m_fingertable[1].ID < id))))
    return 1;
  for(unsigned int i = 1; i < m_fingertable.size(); i++)
  {
    if(m_fingertable[i].ID <= m_fingertable[i + 1].ID) // doesn't overflow
    {
      if((m_fingertable[i].ID <= id) && (m_fingertable[i + 1].ID > id))
        return i;
    }
    else //overflows
    {
      if((m_fingertable[i].ID <= id && (m_fingertable[i + 1].ID < id)) ||
        ((m_fingertable[i].ID > id) && m_fingertable[i+1].ID >= id))
        return i;
    }
  }
  return m_fingertable.size();
}

/*Returns the successor of Node id*/
UpdateDHTInfo successor(const std::vector<UpdateDHTInfo> & NodesList, int id)
{
  //since the list is sorted the first node greather than id is the successor
  //if no node is larger, then id is the largest in the network, in which case
  //the first node of NodesList is the successor
  for(std::vector<UpdateDHTInfo>::const_iterator node = NodesList.begin(); node != NodesList.end(); node++)
  {
    if(node->ID > id)
      return *node;
  }
  return NodesList[0];
}

/*Returns the ID of the predecessor + 1 of Node id*/
int predecessor(const std::vector<UpdateDHTInfo> & NodesList, int id)
{
  if(NodesList.size() == 1)
    return id + 1;
  //since the list is sorted, starting from the highest, the first node smaller
  //than id is the predecessor.  If there is no node smaller, than the highest
  //node is the predecessor
  for(std::vector<UpdateDHTInfo>::const_reverse_iterator iter = NodesList.rbegin(); iter != NodesList.rend(); iter++)
  {
    if(iter->ID < id)
    {
      if(iter->ID == DHT_SIZE - 1)
        return 0;
      return iter->ID + 1;
    }
  }
  if(NodesList[NodesList.size() - 1].ID == DHT_SIZE - 1)
    return 0;
  return NodesList[NodesList.size() - 1].ID + 1;
}

/*Returns IP Address of local machine*/
std::string getIPAddress() {
  struct ifaddrs * ifAddrStruct = NULL;
  struct ifaddrs * ifa = NULL;
  void * tmpAddrPtr = NULL;
  std::string IPAddress = "";

  getifaddrs(&ifAddrStruct);

  for(ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {
    if(!ifa->ifa_addr) {
      continue;
    }

    if(ifa->ifa_addr->sa_family == AF_INET) {
      tmpAddrPtr = &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
      char addressBuffer[INET_ADDRSTRLEN];
      inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);
      IPAddress = std::string(addressBuffer);
    }
  }

  if(ifAddrStruct != NULL)
    freeifaddrs(ifAddrStruct);

  return IPAddress;
}

bool NodeGreater(const UpdateDHTInfo& lhs, const UpdateDHTInfo& rhs)
{
  return lhs.ID < rhs.ID;
}

int main(int argc, char **argv) {

  if(argc != 4) {
    std::cout << "Usage: ./dht_node <my_port> <supernode_IP_address> <supernode_port>" << std::endl;
    return 1;
  }

  //First contact SuperNode for DHTNode Info
  //Broadcast your presence to all other DHT Nodes
  //Call PostJoin() to tell SuperNode you have safely joined DHT
  boost::shared_ptr<TSocket> socket(new TSocket(argv[2], atoi(argv[3])));
  boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));

  DHTNode_SupernodeInterfaceClient SNode(protocol);

  //Get IP Address of machine and read port no. from command line
  int port = atoi(argv[1]);
  std::string ipAddress = getIPAddress();
  IPPort myInfo;
  myInfo.port = port;
  myInfo.ipAddress = ipAddress;

  //Init DHTNode
  shared_ptr<DHTNode_NodeInterfaceHandler> handler(new DHTNode_NodeInterfaceHandler());
  shared_ptr<TProcessor> processor(new DHTNode_NodeInterfaceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  std::vector<NodeInfo> DHTInfo;
  std::vector<NodeInfo> empty;

  transport->open();
  SNode.Join(DHTInfo, myInfo);

  if(DHTInfo == empty) {
    std::cout << "SuperNode is busy or DHT is FULL!" << std::endl;
    return 1;
  }

  //put DHT info into form for DHT nodes to read
  //Would have liked to use NodeInfo vector, but thrift is
  //dumb and won't allow us to do that without a lot of hacking
  std::vector<UpdateDHTInfo> DHTNodeList;
  for(std::vector<NodeInfo>::iterator node = DHTInfo.begin(); node != DHTInfo.end(); node++)
  {
    UpdateDHTInfo info;
    info.ID = node->ID;
    info.port = node->network_info.port;
    info.ipAddress = node->network_info.ipAddress;
    DHTNodeList.push_back(info);
  }


  std::sort(DHTNodeList.begin(), DHTNodeList.end(), NodeGreater); // sort list by IDs

  //Update all nodes in network
  for(std::vector<NodeInfo>::iterator node = DHTInfo.begin(); node != DHTInfo.end(); node++)
  {
    if(!((node->network_info.port == myInfo.port) && //update other nodes
          (node->network_info.ipAddress == myInfo.ipAddress)))
    {
      std::cout << "Connecting to " << node->ID << std::endl;
      boost::shared_ptr<TSocket> DHTsocket(new TSocket(node->network_info.ipAddress,
            node->network_info.port));
      boost::shared_ptr<TTransport> DHTtransport(new TBufferedTransport(DHTsocket));
      boost::shared_ptr<TProtocol> DHTprotocol(new TBinaryProtocol(DHTtransport));
      DHTNode_NodeInterfaceClient DHTNode(DHTprotocol);

      DHTtransport->open();
      DHTNode.UpdateDHT(DHTNodeList);

      DHTtransport->close();
    }
    else //update myself
    {
      handler->setID(node->ID);
      handler->UpdateDHT(DHTNodeList);
    }
  }
  SNode.PostJoin(myInfo);
  transport->close();

  #ifdef DEBUG
  std::cout << "Number of DHT Nodes (including me): " << DHTInfo.size() << std::endl;
  for(std::vector<UpdateDHTInfo>::iterator node = DHTNodeList.begin(); node != DHTNodeList.end(); node++){
    std::cout << "DHTNode " << node->ID << ": <"
      << node->ipAddress << ", "
      << node->port << ">" << std::endl;
  }
  #endif

  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
