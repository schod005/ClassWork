// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileServerInterface.h"
#include <thrift/transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <queue>
#include <pthread.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <netinet/in.h>
#include <string.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <time.h>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

struct Requests {
 std::string iPAddress;
 int port;
 int id;
};

struct FileData {
  WriteFile fileInfo;
  int version;
};

struct UpdateInfo {
  std::vector<ServerInfo> readQuorum;
  FileData latest_write;
};

pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t queue_lock = PTHREAD_MUTEX_INITIALIZER;
void* CoordinatorHandle;

int contains(std::vector<ServerInfo> quorum, ServerInfo item);
std::string getIPAddress();
void* syncWrapper(void* useless);

class FileServerInterfaceHandler : virtual public FileServerInterfaceIf {
 private:
  int coordinator_flag; //If coordinator_flag = 1, then this instance is a coordinator
  std::queue<Requests> requests;
  std::vector<ServerInfo> allServer;
  std::map<std::string, FileData> m_files;
  std::map<std::string, unsigned int> latest_version; //Only coordinator uses this
  int current_node;
  unsigned int NR_NUMBER;
  unsigned int NW_NUMBER;
  int request_id; //Only coordinator uses this instance variable
  int myport;
  std::string coordinator_ip;
  int coordinator_port;
 public:
  FileServerInterfaceHandler() {
    // Your initialization goes here
  }

  FileServerInterfaceHandler(int c_flag, int port, std::string iPAddress, int nr, int nw, std::string cip, int cport) {
   ServerInfo temp;
   temp.port = port;
   temp.ipAddress = iPAddress;
   coordinator_flag = c_flag;
   NR_NUMBER = nr;
   NW_NUMBER = nw;
   request_id = 0;
   myport = port;
   allServer.push_back(temp);
   coordinator_ip = cip;
   coordinator_port = cport;
   current_node = 0;
   srand(time(NULL));
   if(coordinator_flag)
   {
     CoordinatorHandle = (void*)this;
     pthread_t Thread;
     pthread_create(&Thread, NULL, syncWrapper, NULL);
     pthread_detach(Thread);
   }
  }

  void Write(const WriteFile& fileInfo, const int64_t flags) {
    Requests request;
    std::vector<ServerInfo> write_quorum, remainingReplicas;
    int write_version_numbers[NW_NUMBER];
    unsigned int i = 0;
    int max_version_number = -1;
    if(coordinator_flag) {
      request.id = request_id++;
      //queue is not empty => add to queue
      pthread_mutex_lock(&queue_lock);
      requests.push(request);
      pthread_mutex_unlock(&queue_lock);
      if(!requests.empty()) {
        while((requests.front()).id != request.id); //Wait until my turn
      }

      if(NW_NUMBER > allServer.size()/2 && (NR_NUMBER + NW_NUMBER > allServer.size())
         && NW_NUMBER <= allServer.size()) {
        //Assemble write quorum
        remainingReplicas = allServer;
        int erase_index = 0;
        while(i < NW_NUMBER) {
          erase_index = rand()%remainingReplicas.size();
          write_quorum.push_back(remainingReplicas[erase_index]);
          remainingReplicas.erase(remainingReplicas.begin()+erase_index);
          i++;
        }

        //update version number
        latest_version[fileInfo.filename]++;

        std::cout << "Scanning for latest version of " << fileInfo.filename << " in write quorum" << std::endl;
        //scan write quorum for latest version number
        for(unsigned int x = 0; x < write_quorum.size(); x++) {
          //send request to every quorum asking for version number except cooridnator
          if(write_quorum[x].ipAddress == getIPAddress() && write_quorum[x].port == myport){
            write_version_numbers[x] = m_files[fileInfo.filename].version;
            continue;
          }

          shared_ptr<TSocket> socket(new TSocket(write_quorum[x].ipAddress, write_quorum[x].port));
          shared_ptr<TTransport> transport(new TBufferedTransport(socket));
          shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
          FileServerInterfaceClient WFileServer(protocol);

          //connect to node and call getVersion()
          transport->open();
          write_version_numbers[x] = WFileServer.getVersion(fileInfo.filename);
          transport->close();

        }
        //Find greatest version number
        for(unsigned int x = 0; x < NW_NUMBER; x++) {
          if(write_version_numbers[x] > max_version_number) {
            max_version_number = write_version_numbers[x];
          }
        }
        std::cout << fileInfo.filename << "'s latest version number: " << max_version_number << std::endl;
        std::cout << "Writing to replica with latest version number" << std::endl;
        //write to replicas with latest version numbers
        std::vector<ServerInfo> remainingWriteReplicas;
        WriteFile latest_copy, dummy;
        for(unsigned int x = 0; x < write_quorum.size(); x++) {
          if(write_version_numbers[x] == max_version_number) {
            if(write_quorum[x].ipAddress == getIPAddress() && write_quorum[x].port == myport) {
              m_files[fileInfo.filename].version = max_version_number+1;
              m_files[fileInfo.filename].fileInfo.file += fileInfo.file; //Appending the contents of appendFile
              continue;
            }
            //Write to file at write_quorum[max_index]
            shared_ptr<TSocket> socket(new TSocket(write_quorum[x].ipAddress, write_quorum[x].port));
            shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            FileServerInterfaceClient WFileServer(protocol);

            transport->open();
            WFileServer.updateFile(latest_copy, fileInfo, max_version_number+1, 0);
            transport->close();
          } else {
            remainingWriteReplicas.push_back(write_quorum[x]);
          }
        }

        std::cout << "Copying file to the rest of the write quorum..." << std::endl;
        //Copy file from any up-to-date replica to remaining replicas in write quorum
        for(unsigned int x = 0; x < remainingWriteReplicas.size(); x++) {
            if(remainingWriteReplicas[x].ipAddress == getIPAddress() && remainingWriteReplicas[x].port == myport) {
              m_files[fileInfo.filename].version = max_version_number+1;
              m_files[fileInfo.filename].fileInfo.file = fileInfo.file; //Overwrite the contents
              continue;
            }
            //Write to file at write_quorum[max_index]
            shared_ptr<TSocket> socket(new TSocket(remainingWriteReplicas[x].ipAddress, remainingWriteReplicas[x].port));
            shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            FileServerInterfaceClient WFileServer(protocol);

            transport->open();
            WFileServer.updateFile(dummy, latest_copy, max_version_number+1, 0);
            transport->close();
        }
      } else {
        std::cout << "N_W and N_R don't meet the requirements" << std::endl;
      }
      requests.pop();
    } else {
      //Send request to coordinator
      shared_ptr<TSocket> Csocket(new TSocket(coordinator_ip, coordinator_port));
      shared_ptr<TTransport> Ctransport(new TBufferedTransport(Csocket));
      shared_ptr<TProtocol> Cprotocol(new TBinaryProtocol(Ctransport));
      FileServerInterfaceClient Coordinator(Cprotocol);

      //connect to node and call write
      Ctransport->open();
      Coordinator.Write(fileInfo, 0);
      Ctransport->close();

    }
    printf("Write\n");
  }

  /*Reads can be concurrent, but writes can't*/
  void Read(ReadFile& _return, const std::string& filename, const int64_t flags) {
    Requests request;
    std::vector<ServerInfo> read_quorum;
    ServerInfo temp, Contact;
    unsigned int i = 0;
    _return.error = 1; //assume file wasn't found

    if(coordinator_flag) {
      request.id = request_id++;
      //queue is not empty => add to queue
      pthread_mutex_lock(&queue_lock);
      requests.push(request);
      pthread_mutex_unlock(&queue_lock);
      if(!requests.empty()) {
        while((requests.front()).id != request.id); //Wait until my turn
      }

      if(NW_NUMBER > allServer.size()/2 && (NR_NUMBER + NW_NUMBER > allServer.size())
         && NR_NUMBER <= allServer.size()) {
        //Assemble read quorum
        while(i < NR_NUMBER) {
          temp = allServer[rand()%allServer.size()];
          if(!contains(read_quorum, temp)) {
            read_quorum.push_back(temp);
            i++;
          }
        }

        //scan read quorum for latest version number
        for(unsigned int x = 0; x < read_quorum.size(); x++) {
          //send request to every quorum asking for version number
          shared_ptr<TSocket> socket(new TSocket(read_quorum[x].ipAddress, read_quorum[x].port));
          shared_ptr<TTransport> transport(new TBufferedTransport(socket));
          shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
          FileServerInterfaceClient RFileServer(protocol);

          //connect to node and call getVersion()
          transport->open();
          if(RFileServer.getVersion(filename) == latest_version[filename]) //version is latest
          {
            RFileServer.getFile(_return, filename); //read file
            break;
          }
          transport->close();

        }
        _return.version = latest_version[filename];
        if(_return.error)
        {
          _return.errorMessage = "File not found";
        }


      } else {
        std::cout << "N_W and N_R don't meet the requirements" << std::endl;
      }
      requests.pop();
    } else {
        //Send request to coordinator
        shared_ptr<TSocket> socket(new TSocket(coordinator_ip, coordinator_port));
        shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        FileServerInterfaceClient Coordinator(protocol);

        transport->open();
        Coordinator.Read(_return, filename, 0);
        transport->close();
      }
      printf("Read\n");
    }

  void getAllServers(std::vector<ServerInfo> & _return) {
    _return = allServer;
    printf("getAllServers\n");
  }

  int64_t Register(const ServerInfo& myInfo) {
    ServerInfo temp;
    if(coordinator_flag)
    {
      pthread_mutex_lock(&m);
      temp.port = myInfo.port;
      temp.ipAddress = myInfo.ipAddress;
      allServer.push_back(temp);
      pthread_mutex_unlock(&m);
      printf("Register\n");
      return 1;
    } else {
      printf("Non-coordinator isn't supposed to be responsible for registering\n");
      return 0;
    }
  }

  int64_t getVersion(const std::string& filename) {
    return m_files[filename].version;
    printf("getVersion\n");
  }

  void updateFile(WriteFile& _return, const WriteFile& appendFile, const int64_t version, const int64_t append_flag) {
    m_files[appendFile.filename].version = version;
    if(append_flag) {
      m_files[appendFile.filename].fileInfo.file += appendFile.file; //Appending the contents of appendFile
      m_files[appendFile.filename].fileInfo.filename = appendFile.filename;
    } else {
      m_files[appendFile.filename].fileInfo.file = appendFile.file;
      m_files[appendFile.filename].fileInfo.filename = appendFile.filename;
    }
    _return = m_files[appendFile.filename].fileInfo;
    printf("updateFile\n");
  }

  void getFile(ReadFile& _return, const std::string& filename) {
    _return.file = m_files[filename].fileInfo.file;
    _return.filename = filename;
    _return.error = 0;
    printf("getFile\n");
  }

  //when there is nothing in the request queue, this function will sequentially
  //update all files on all nodes in the network
  //function is called on a timer
  void sync()
  {
    if(coordinator_flag)
    {
      if(requests.empty())
      {
        std::cout << "Syncing server " << allServer[current_node].ipAddress << ":"
          << allServer[current_node].port << std::endl;

        shared_ptr<TSocket> socket2(new TSocket(allServer[current_node].ipAddress, allServer[current_node].port));
        shared_ptr<TTransport> transport2(new TBufferedTransport(socket2));
        shared_ptr<TProtocol> protocol2(new TBinaryProtocol(transport2));
        FileServerInterfaceClient UpdateFileServer(protocol2);

        transport2->open();
        for(std::map<std::string, unsigned int>::iterator iter = latest_version.begin(); iter != latest_version.end(); iter++)
        {
          //check if server has latest version
          if(UpdateFileServer.getVersion(iter->first) != iter->second)
          {
            std::cout << "  Updating " << iter->first << " to version " << iter->second << std::endl;
            ServerInfo Contact;
            ReadFile rFile;
            WriteFile wFile;
            WriteFile useless;

            //scan for latest version number
            for(unsigned int x = 0; x < allServer.size(); x++) {
              //send request to every node asking for version number until one is found with the latest version
              shared_ptr<TSocket> socket(new TSocket(allServer[x].ipAddress, allServer[x].port));
              shared_ptr<TTransport> transport(new TBufferedTransport(socket));
              shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
              FileServerInterfaceClient WFileServer(protocol);

              //connect to node and call getVersion()
              transport->open();
              if(WFileServer.getVersion(iter->first) == latest_version[iter->first]) //found server with latest version
              {
                Contact = allServer[x];
                break;
              }
              transport->close();
            }

            //get latest version of file
            shared_ptr<TSocket> socket(new TSocket(Contact.ipAddress, Contact.port));
            shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            FileServerInterfaceClient ContactFileServer(protocol);

            transport->open();
            ContactFileServer.Read(rFile, iter->first, 0);
            transport->close();

            wFile.file = rFile.file;
            wFile.filename = rFile.filename;

            //update file
            UpdateFileServer.updateFile(useless, wFile, latest_version[iter->first], 0);
          }
        }
        transport2->close();
        current_node = (current_node + 1) % allServer.size();
      }
      usleep(1000000);
      pthread_t Thread;
      pthread_create(&Thread, NULL, syncWrapper, NULL);
      pthread_detach(Thread);
    }
  }

  //This function returns the coordinator's list of all files and version numbers
  void listFiles(std::vector<FileInfo> & _return) {
    if(coordinator_flag)
    {
      for(std::map<std::string, FileData>::iterator iter = m_files.begin(); iter != m_files.end(); iter++)
      {
        FileInfo info;
        info.filename = iter->first;
        info.version = iter->second.version;
        _return.push_back(info);
      }
      printf("listFiles\n");
    } else {
      //Send request to coordinator
      shared_ptr<TSocket> socket(new TSocket(coordinator_ip, coordinator_port));
      shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      FileServerInterfaceClient Coordinator(protocol);

      transport->open();
      Coordinator.listFiles(_return);
      transport->close();
    }
  }
};

/*Returns IP Address of local machine*/
std::string getIPAddress() {
  struct ifaddrs * ifAddrStruct = NULL;
  struct ifaddrs * ifa = NULL;
  void * tmpAddrPtr = NULL;
  std::string IPAddress = "";

  getifaddrs(&ifAddrStruct);

  for(ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {
    if(!ifa->ifa_addr) {
      continue;
    }

    if(ifa->ifa_addr->sa_family == AF_INET) {
      tmpAddrPtr = &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
      char addressBuffer[INET_ADDRSTRLEN];
      inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);
      IPAddress = std::string(addressBuffer);
    }
  }

  if(ifAddrStruct != NULL)
    freeifaddrs(ifAddrStruct);

  return IPAddress;
}

int contains(std::vector<ServerInfo> quorum, ServerInfo item) {
  if(!quorum.size()) return 0;

  for(unsigned int i = 0; i < quorum.size(); i++) {
    if(item.port == quorum[i].port && item.ipAddress.compare(quorum[i].ipAddress) == 0) {
      return 1;
    }
  }

  return 0;
}

void* syncWrapper(void* useless)
{
  ((FileServerInterfaceHandler*)CoordinatorHandle)->sync();
  return useless;
}

int main(int argc, char **argv) {
  int port;
  int coordinator_flag;
  int NR_NUMBER;
  int NW_NUMBER;
  std::string coordinator_ip;
  int coordinator_port;
  ServerInfo myInfo;

  //command line: ./file_server port_number coordinator_option coordinator_ip coordinator_port NR_NUMBER NW_NUMBER
  //NR_NUMBER NW_NUMBER should only be specified if coordinator_option = 1
  //coordinator_ip coordinator_port should only be specified if coordinator option = 0
  if(argc != 5) {
    std::cout << "Usage: ./file_server <port> 1 NR_NUMBER NW_NUMBER" << std::endl;
    std::cout << "    OR ./file_server <port> 0 coordinator_ip coordinator_port" << std::endl;
    return 1;
  }

  //Based on the coordinator_option, initialize components needed for communication
  coordinator_flag = atoi(argv[2]);
  if(coordinator_flag) {
    port = atoi(argv[1]);
    NR_NUMBER = atoi(argv[3]);
    NW_NUMBER = atoi(argv[4]);
  } else {
    port = atoi(argv[1]);
    coordinator_ip = std::string(argv[3]);
    coordinator_port = atoi(argv[4]);
    myInfo.port = port;
    myInfo.ipAddress = getIPAddress();
    //Register with coordinator
    shared_ptr<TSocket> Csocket(new TSocket(coordinator_ip, coordinator_port));
    shared_ptr<TTransport> Ctransport(new TBufferedTransport(Csocket));
    shared_ptr<TProtocol> Cprotocol(new TBinaryProtocol(Ctransport));
    FileServerInterfaceClient Coordinator(Cprotocol);

    //connect to node and call write
    Ctransport->open();
    if(Coordinator.Register(myInfo)) std::cout << "Successfully registered with coordinator" << std::endl;
    Ctransport->close();
  }

  shared_ptr<FileServerInterfaceHandler> handler(new FileServerInterfaceHandler(coordinator_flag, port, getIPAddress(), NR_NUMBER, NW_NUMBER, coordinator_ip, coordinator_port));
  shared_ptr<TProcessor> processor(new FileServerInterfaceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

//  if(coordinator_flag)
//    CoordinatorHandle = handler;

  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
